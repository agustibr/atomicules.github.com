---
layout: page
type: text
title: Shoes
categories: 
- program
---
<p>Three years ago I used Ruby to write my first program with a GUI, using the almost-built-in <a href="http://members.chello.nl/k.vangelder/ruby/learntk/">Tk toolkit</a>. It wasn't very exciting*, but it impressed me as I had a working bit of software on my screen that I'd created and yet I didn't really know anything about programming. I still profess I still don't really know how to program, sure I can hack about a bit, but when it gets to classes and modules, and organising things into separate files, I glaze over.</p>
<p>Ruby wasn't very quick, not when searching 6.5 million line files anyway. I'd developed the programme in <a href="http://www.gnu.org/software/octave/">Octave</a> first which was very fast (the programme  was mainly matrix manipulation), but it was <a href="http://www.ruby-doc.org/stdlib/libdoc/matrix/rdoc/classes/Matrix.html">easy to port to Ruby</a> where it was then (relatively) easy to build a GUI using Tk. I then had a programme that was much nicer to use. And fairly portable.</p>
<p>Three years on and things are much improved as far as building GUIs goes: <a href="http://www.tutorialspoint.com/ruby/ruby_tk_guide.htm">Compare</a> and <a href="http://shoooes.net/tutorial/">Contrast</a>. Or for a specific example:</p>
<p>In Tk,</p>
<pre>require 'tk'<br />require 'tkextlib/bwidget'<br /><br />root = TkRoot.new<br />root.title = "Window"<br /><br />combobox = Tk::BWidget::ComboBox.new(root)<br />combobox.values = [1, 2, 3, 4]<br />combobox.place('height' =&gt; 25,<br />               'width'  =&gt; 100,<br />               'x'      =&gt; 10,<br />               'y'      =&gt; 10)<br /><br />Tk.mainloop<br /><br /></pre>
<p>In Shoes,</p>
<pre>Shoes.app :title =&gt; "Shoes is fab" do<br />  list_box :items =&gt; [1, 2, 3, 4], <br />  :height =&gt; 25, <br />  :width =&gt; 100, <br />  :left =&gt; 10,<br />  :top =&gt; 10<br />end<br /><br /></pre>
<p><a href="http://shoooes.net">Shoes</a> is just that little bit more pretty. And understandable.</p>
<p>Tk did also used to look rubbish, but it seems with version 8 it can <a href="http://tktable.sourceforge.net/tile/">emulate the look and feel of the platform</a> it is running on; Shoes actually uses platform native widgets. To use  Tk, you  need Ruby (or language of choice) installed on whatever operating system you use and you also then need to install Tk itself. Whereas Shoes seems to work the other way round: it's a graphics toolkit that contains Ruby. This makes Shoes programmes much more easy to distribute as you can create executables for Linux, Mac and Windows and the executable contains everything that is needed to run. Shoes is also a smaller download than <a href="http://www.activestate.com/activetcl/">Tcl/Tk</a> itself.</p>
<p>The benefit of Tk over Shoes, would be that Shoes is Ruby only, whereas Tk can be used with many other languages. Alos, Shoes also isn't intended for big applications, it's more for building dashboard/widget style apps. See here for some <a href="http://the-shoebox.org/">example Shoes applications</a>.</p>
<p>However, Shoes is just a mind-blowingly awesome thing. It's not yet big news (I don't think?), but it should be. It really is power to the people. When I was little you could spend ages programming from books like <a href="http://www.btinternet.com/~pweighill/music/books/#ComputerSpacegames">Usborne Computer Spacegames</a> only to be outrageously disappointed by the end result you got on the screen. It probably put me off programming. With Shoes you can actually do cool things quickly. Without being a 'programmer'. I think that is more likely to inspire people to try and do more.</p>
<p>Again, a quick(?!) post has gone on too long. But just to finish with: As far as I know Shoes is being developed as a base for <a href="http://hacketyhack.net/">Hackety Hack</a>, <a href="http://whytheluckystiff.net/">_why</a>'s teaching-kids-to-programme tool. And Shoes 3 should be out in the next month or so.</p>
<p>* <i>I was interested so dug it out this weekend: It analysed ANSYS raw output node files looking for the node closest to a user entered co-ordinate, then used this to search the element solution file and output results for all occurrences of the node. If that node wasn't found in the element solution file, it used the next closest node, and so on. The end result could then be used to check for convergence and discontinuity.</i></p> 
